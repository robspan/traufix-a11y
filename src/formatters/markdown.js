'use strict';

/**
 * Markdown Formatter
 *
 * Generates markdown reports suitable for PR comments, documentation,
 * and GitHub/GitLab wiki pages.
 *
 * @module formatters/markdown
 */

const { normalizeResults, getWorstEntities, getCheckWeight } = require('./result-utils');

function getEntityNouns(results, normalized) {
  const kind = (() => {
    if (results && typeof results === 'object' && typeof results.totalComponentsScanned === 'number') return 'component';
    if (results && typeof results === 'object' && results.summary && Array.isArray(results.summary.issues)) return 'file';
    return normalized?.entities?.[0]?.kind || 'page';
  })();

  if (kind === 'component') return { singular: 'Component', plural: 'Components' };
  if (kind === 'file') return { singular: 'File', plural: 'Files' };
  return { singular: 'URL', plural: 'URLs' };
}

/**
 * Get status icon based on score
 * @param {number} score - Audit score (0-100)
 * @returns {string} Status icon
 */
function getStatusIcon(score) {
  if (score >= 90) return 'PASS';
  if (score >= 50) return 'WARN';
  return 'FAIL';
}

/**
 * Get status label based on score
 * @param {number} score - Audit score (0-100)
 * @returns {string} Status label
 */
function getStatusLabel(score) {
  if (score >= 90) return 'passing';
  if (score >= 50) return 'warning';
  return 'failing';
}

/**
 * Escape pipe characters for markdown tables
 * @param {string} str - String to escape
 * @returns {string} Escaped string
 */
function escapeMarkdown(str) {
  if (!str) return '';
  return String(str).replace(/\|/g, '\\|').replace(/\n/g, ' ');
}

/**
 * Generate ASCII bar chart
 * @param {number} value - Current value
 * @param {number} total - Total value
 * @param {number} width - Bar width in characters
 * @returns {string} ASCII bar
 */
function generateBar(value, total, width = 20) {
  if (total === 0) return '';
  const filled = Math.round((value / total) * width);
  return '#'.repeat(filled) + '-'.repeat(width - filled);
}

/**
 * Format the results into a markdown report
 *
 * @param {object} results - Analysis results
 * @param {Array} results.urls - Array of URL results
 * @param {object} results.distribution - Score distribution {passing, warning, failing}
 * @param {string} results.tier - Analysis tier
 * @param {number} results.urlCount - Total URL count
 * @param {Array} [results.worstUrls] - Array of worst performing URLs
 * @param {object} [options={}] - Formatter options
 * @param {string} [options.title] - Report title
 * @param {boolean} [options.includeTimestamp=true] - Include generation timestamp
 * @param {boolean} [options.includeSummary=true] - Include summary section
 * @param {boolean} [options.includeDistribution=true] - Include distribution chart
 * @param {boolean} [options.includeWorstUrls=true] - Include worst URLs section
 * @param {boolean} [options.includeAllUrls=true] - Include all URLs table
 * @param {number} [options.worstUrlsLimit=10] - Maximum worst URLs to show
 * @returns {string} Formatted markdown report
 */
function format(results, options = {}) {
  const {
    title = 'mat-a11y Accessibility Report',
    includeTimestamp = true,
    includeSummary = true,
    includeDistribution = true,
    includeWorstUrls = true,
    includeAllUrls = true,
    worstUrlsLimit = 10
  } = options;

  const lines = [];
  const normalized = normalizeResults(results);

  const nouns = getEntityNouns(results, normalized);

  const urls = normalized.entities || [];
  const distribution = normalized.distribution || { passing: 0, warning: 0, failing: 0 };
  const urlCount = normalized.total || urls.length;

  // Header
  lines.push('<!-- Generated by mat-a11y - do not edit -->');
  lines.push('');
  lines.push(`# ${title}`);
  lines.push('');

  // Metadata
  lines.push(`**Tier:** ${results.tier || 'standard'}`);
  if (results.sitemapPath) {
    lines.push(`**Sitemap:** ${results.sitemapPath}`);
  }
  if (includeTimestamp) {
    lines.push(`**Generated:** ${new Date().toISOString()}`);
  }
  lines.push('');

  // Summary table
  if (includeSummary) {
    lines.push('## Summary');
    lines.push('');
    lines.push('| Metric | Value |');
    lines.push('|--------|-------|');
    lines.push(`| ${nouns.plural} Analyzed | ${urlCount} |`);
    lines.push(`| Passing (90-100%) | ${distribution.passing} |`);
    lines.push(`| Warning (50-89%) | ${distribution.warning} |`);
    lines.push(`| Failing (<50%) | ${distribution.failing} |`);
    lines.push('');
  }

  // Distribution chart
  if (includeDistribution && urlCount > 0) {
    lines.push('## Distribution');
    lines.push('');
    lines.push('```');
    lines.push(`Passing: [${generateBar(distribution.passing, urlCount)}] ${distribution.passing} (${Math.round((distribution.passing / urlCount) * 100)}%)`);
    lines.push(`Warning: [${generateBar(distribution.warning, urlCount)}] ${distribution.warning} (${Math.round((distribution.warning / urlCount) * 100)}%)`);
    lines.push(`Failing: [${generateBar(distribution.failing, urlCount)}] ${distribution.failing} (${Math.round((distribution.failing / urlCount) * 100)}%)`);
    lines.push('```');
    lines.push('');
  }

  // Priority Fixes section (entities are pre-sorted by totalPoints descending)
  if (includeWorstUrls) {
    // Use pre-sorted entities with issuePoints from normalizeResults
    const priorityEntities = urls
      .filter(u => (u.auditScore ?? 0) < 90 && u.issuePoints?.totalPoints > 0)
      .slice(0, worstUrlsLimit);

    if (priorityEntities.length > 0) {
      // Calculate total priority points for header
      const totalPoints = priorityEntities.reduce((sum, u) => sum + (u.issuePoints?.totalPoints || 0), 0);

      lines.push('## Priority Fixes');
      lines.push('');
      lines.push(`${nouns.plural} sorted by priority (${totalPoints} total priority points):`);
      lines.push('');

      for (const url of priorityEntities) {
        const score = url.auditScore ?? 0;
        const points = url.issuePoints || { basePoints: 0, usageCount: 1, totalPoints: 0 };
        const pointsDisplay = points.usageCount > 1
          ? `${points.totalPoints}pts (${points.basePoints} x ${points.usageCount} uses)`
          : `${points.basePoints}pts`;

        lines.push(`### ${escapeMarkdown(url.label)} (${score}%) - ${pointsDisplay}`);
        lines.push('');

        // Get top issues for this URL (sorted by weight)
        const topIssues = getTopIssuesWithWeight(url);
        if (topIssues.length > 0) {
          lines.push('| Check | Weight | Count |');
          lines.push('|-------|--------|-------|');
          for (const issue of topIssues.slice(0, 5)) {
            lines.push(`| \`${escapeMarkdown(issue.check)}\` | ${issue.weight} | ${issue.count} |`);
          }
          lines.push('');
        }
      }
    }
  }

  // All URLs table (entities are pre-sorted by priority - highest totalPoints first)
  if (includeAllUrls && urls.length > 0) {
    lines.push(`## All ${nouns.plural}`);
    lines.push('');
    lines.push(`| ${nouns.singular} | Score | Status | Issues | Priority |`);
    lines.push('|-----|-------|--------|--------|----------|');

    for (const url of urls) {
      const score = url.auditScore ?? 0;
      const status = getStatusIcon(score);
      const issueCount = url.issues ? url.issues.length : 0;
      const points = url.issuePoints?.totalPoints || 0;
      lines.push(`| ${escapeMarkdown(url.label)} | ${score}% | ${status} | ${issueCount} | ${points}pts |`);
    }
    lines.push('');
  }

  // Internal pages section (if present)
  if (results.internal && results.internal.count > 0) {
    lines.push('## Internal Pages');
    lines.push('');
    lines.push(`*${results.internal.count} routes not in sitemap*`);
    lines.push('');
    const id = results.internal.distribution || { passing: 0, warning: 0, failing: 0 };
    lines.push('| Passing | Warning | Failing |');
    lines.push('|---------|---------|---------|');
    lines.push(`| ${id.passing} | ${id.warning} | ${id.failing} |`);
    lines.push('');
  }

  // Footer
  lines.push('---');
  lines.push('*Generated by [mat-a11y](https://github.com/robspan/mat-a11y)*');
  lines.push('');
  lines.push('*[traufix.de](https://traufix.de) | [freelancermap.de/profil/robin-spanier](https://www.freelancermap.de/profil/robin-spanier)*');

  return lines.join('\n');
}

/**
 * Extract top issues from a URL result (sorted by weight descending)
 * @param {object} url - URL result object
 * @returns {Array} Array of {check, count, weight} objects sorted by weight
 */
function getTopIssuesWithWeight(url) {
  if (!url.issues || url.issues.length === 0) {
    return [];
  }

  // Count issues by check type and track weight
  const checkData = {};
  for (const issue of url.issues) {
    const check = issue.check || 'unknown';
    if (!checkData[check]) {
      // Use pre-computed weight from normalizeResults or fetch it
      const weight = issue.weight !== undefined ? issue.weight : getCheckWeight(check);
      checkData[check] = { count: 0, weight };
    }
    checkData[check].count++;
  }

  // Convert to array and sort by weight descending (highest priority first)
  return Object.entries(checkData)
    .map(([check, data]) => ({ check, count: data.count, weight: data.weight }))
    .sort((a, b) => b.weight - a.weight);
}

/**
 * Extract top issues from a URL result (legacy - sorted by count)
 * @param {object} url - URL result object
 * @returns {Array} Array of {check, count} objects
 */
function getTopIssues(url) {
  if (!url.issues || url.issues.length === 0) {
    return [];
  }

  // Count issues by check type
  const counts = {};
  for (const issue of url.issues) {
    const check = issue.check || 'unknown';
    counts[check] = (counts[check] || 0) + 1;
  }

  // Convert to array and sort by count
  return Object.entries(counts)
    .map(([check, count]) => ({ check, count }))
    .sort((a, b) => b.count - a.count);
}

module.exports = {
  name: 'markdown',
  description: 'Markdown report for PR comments, documentation, and wiki pages',
  category: 'docs',
  output: 'text',
  fileExtension: '.md',
  mimeType: 'text/markdown',
  format
};
